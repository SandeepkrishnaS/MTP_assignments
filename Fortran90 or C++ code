/* C++ program to implement Runge Kutta method 
Taken from https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods
*/

/* This kind of comment allows you to wrtie longer descriptions and not
 * just limited to one line as allowed by //, though // is very useful for 
 * quick comments.
 */

/* Global and local variables. Would it be possible to define few variables/parameters
 * that would be often used in a large code as global? May be a header file? I don't remember
 * much, it is like 20 years that I last used c++. In fortran you can define modules and inside
 * modules you can declare the global variables. Now if you include this in any subroutine in
 * fortran these variables would be available in that subroutine.
 * Here, for example, space step-size h (or dx), time step size dt are likely to be global. So is
 * maxtier the maximum number of iterations.
 */

/* How would you go about a problem dy/dt = f(x,t), if you are given a domain x \in [0,2pi).
 * Let's say that you want to discretize over Nx number of points. Then box-lenght or
 * domian size is Lx = 2*pi. Therefore, the step-size is dx = Lx/Nx (I'm assuming type conversion
 * to real/float). Let the time-step size be dt, and the maximum number of iterations maxtier.
 * Now you would evolving one dimensional fields!
 */


#include<iostream>
using namespace std;
  
// A sample differential equation "dy/dx = (x - y)/2" 
float dydx(float x, float y) 
{ 
    return((x - y)/2); 
} 
  
// Finds value of y for a given x using step size h and initial value y0 at x0. 
float RK(float x0, float y0, float x, float h) 
{ 
    // Count number of iterations using step size or step height h 
    int n = (int)((x - x0) / h); 
  
    float k1, k2, k3, k4, k5; 
  
    // Iterate for number of iterations 
    float y = y0; 
    for (int i=1; i<=n; i++) 
    { 
        // Apply Runge Kutta Formulas to find next value of y and update x
        k1 = h*dydx(x0, y); 
        k2 = h*dydx(x0 + 0.5*h, y + 0.5*k1); 
        k3 = h*dydx(x0 + 0.5*h, y + 0.5*k2); 
        k4 = h*dydx(x0 + h, y + k3); 
  
        // Update next value of y 
        y = y + (1.0/6.0)*(k1 + 2*k2 + 2*k3 + k4);
  
        // Update next value of x 
        x0 = x0 + h; 
    } 
  
    return y; 
} 
   
int main() 
{ 
    float x0 = 0, y = 1, x = 3, h = 0.1; 
    cout<<endl<<"The value of y at x is : "<<RK(x0, y, x, h); 
    return 0; 
} 
